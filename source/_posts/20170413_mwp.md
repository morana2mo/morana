---
title: 原型
---
在js中对象有个特殊的[[Prototype]]内置属性
每个对象的[[Prototype]]都会打印出该对象本身的内置方法。(举例如下)
``` 
var obj = {name:'morana'}
obj.__proto__  
//Object {__defineGetter__: function, __defineSetter__: function, hasOwnProperty: function, __lookupGetter__: function, __lookupSetter__: function…}
function fuc(){console.log('啦啦啦')}
func.__proto__
//function () { [native code] }
var arr = [1,2,3];
arr.__proto__
//[constructor: function, toString: function, toLocaleString: function, join: function, pop: function…]
```
那[[Prototype]]引用有什么用？
上述的obj对象中用一个"name"属性，当你使用obj.name会触发[[Get]]操作，而默认是先检查对象本身是否有这个属性，有的话就使用。没有的话，就需要使用对象的[[Prototype]]链了。(举例如下)

```
var anotherObj = {
    name:'morana'
}
var obj = Object.create(anotherObj)

obj.name
//morana
```

如果obj在anotherObj中也没有name属性，就会随着[[Prototype]]这条链持续找到匹配的属性名，反之，[[Get]]操作会返回undefined

而for...in遍历对象的原型和查找[[Prototype]]链类似

```
var anotherObj = {
    name:'morana'
}
var obj = Object.create(anotherObj)
for(var i in obj){
    console.log('found：' + i);
}
//found:name

('name' in obj) // true

```

而所有普通的对象通过[[Prototype]]链都会指向内置的Object.prototype
由于所用的"普通"（内置非特定主机的扩展）对象的最顶层为Object.prototype,所以它包含js中许多通过的功能。

js是少有的可以不通过类，直接创建对象的语言。

所用的函数拥有一个名为prototype的共有且不可枚举的属性，它指向的是另一个对象
```
function Fuc(){
    //...
}
Fuc.prototype;//{}
```
这个对象通常称为Fuc的原型，因为可以通过Fuc.prototype的属性引用来访问它。
最直接的解释就是：这个对象是在调用new Fuc()是创建，最后会被关联到Fuc.prototype对象上

分析：new Fuc()会生成一个新对象，而这个新对象的内部链接[[Prototype]]

另外Fuc.prototype有一个共有并且不可枚举的属性.constructor,这个属性引用的是对象关联的函数（本例为Fuc）。
构造函数调用new Func()创建的对象也有一个.constructor属性，指向"创建这个对象的函数"
```
js模仿类的行为
function Foo(name){
    this.name = name
}
Foo.prototype.myName = function(){
    return this.name;
}
var a = new Foo('a');
var b = new Foo('b');

a.myName();//'a'
b.myName();//'b'
```

解释：为什么a.myName()可以正常工作的原理？
a,b在创建的过程中，其内部[[prototype]]都会关联到Foo.prototype上。
当a,b无法找到myName上，她会在Foo.prototype上找





