---
title: 原型
---
在js中对象中有个特殊的[[Prototype]]内置属性
每个对象的[[Prototype]]都会打印出该对象本身的内置方法。(举例如下)
``` 
var obj = {name:'morana'}
obj.__proto__  
//Object {__defineGetter__: function, __defineSetter__: function, hasOwnProperty: function, __lookupGetter__: function, __lookupSetter__: function…}
function fuc(){console.log('啦啦啦')}
func.__proto__
//function () { [native code] }
var arr = [1,2,3];
arr.__proto__
//[constructor: function, toString: function, toLocaleString: function, join: function, pop: function…]
```
那[[Prototype]]引用有什么用？
上述的obj对象中用一个"name"属性，当你使用obj.name会触发[[Get]]操作，而默认是先检查对象本身是否有这个属性，有的话就使用。没有的话，就需要需要对象的[[Prototype]]链了。(举例如下)

```
var anotherObj = {
    name:'morana'
}
var obj = Object.create(anotherObj)

obj.name
//morana
```

如果obj在anotherObj中也没有name属性，就会随着[[Prototype]]这条链持续找到匹配的属性名，反之，[[Get]]操作会返回undefined

而for...in遍历对象的原型和查找[[Prototype]]链类似

```
var anotherObj = {
    name:'morana'
}
var obj = Object.create(anotherObj)
for(var i in obj){
    console.log('found：' + i);
}
//found:name

('name' in obj) // true

```

而所有普通的对象通过[[Prototype]]链都会指向内置的Object.prototype
由于所用的"普通"（内置非特定主机的扩展）对象的最顶层为Object.prototype,所以它包含js中许多通过的功能。

js是少有的可以不通过类，直接创建对象的语言。

所用的函数拥有一个名为prototy的共有并且不可枚举的属性，它会指向另一个对象
```
function Fuc(){
    //...
}
Foo.prototype;//{}
```
这个对象通常称为Fuc的原型，因为可以通过Fuc.prototype的属性引用来访问它。
最直接的解释就是：这个对象是在调用new Fuc()是创建，最后会被关联到Fuc.prototype对象上

分析：new Fuc()会生成一个新对象，而这个新对象的内部链接[[Prototype]]








