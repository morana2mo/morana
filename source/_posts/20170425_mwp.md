---
title: es6总结之Generator函数
---
语法上，可以理解Generator函数是一个状态机，封装了多个内部状态
执行Generator函数会返回一个遍历器对象，

yield和return的区别
相同：

异步编程的方法：
1，回调函数
2，事件监听
3，发布/订阅
4，Promise对象
所谓异步就是在执行一段任务时，把任务分为两段，先操作完第一步时，然后执行其他任务，等操作返回任务，再执行第二步
不连续的执行叫做异步，反之连读不断的叫做同步

1,所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数

```
    $.ajax(url,function(data){
        console.log(data)
    })
```

2,由于回调本身的局限性，如果多个回调嵌套，代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为"回调函数噩梦"
Promise就是为了解决这个问题而提出的
```
function getNumber(){
   var p = return new Promise(function(resolve, reject){
       var num = Math.ceil(Math.random()*10); //生成1-10的随机数
            if(num<=5){
                resolve(num);
            }
            else{
                reject('数字太大了');
        } 
    })
    return p;
}
getNumber()
.then(
    function(data){
        console.log('resolved');
        console.log(data);
        return getNumber2();
    }, 
    function(reason, data){
        console.log('rejected');
        console.log(reason);
    }
).then(
    function(data){
        console.log('resolved');
        console.log(data);
    }, 
    function(reason, data){
        console.log('rejected');
        console.log(reason);
    }
)

```
3,Generator函数
Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）
```
function* gen(x){
  var y = yield x + 2;
  return y;
}
var g = gen(1);
g.next() // { value: 3, done: false }
g.next() // { value: undefined, done: true }
```
Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。
```
function* gen(x){
  try {
    var y = yield x + 2;
  } catch (e){ 
    console.log(e);
  }
  return y;
}

var g = gen(1);
g.next();
g.throw（'出错了'）;
// 出错了
```
Generator 函数的用法
```

var fetch = require('node-fetch');

function* gen(){
  var url = 'https://api.github.com/users/github';
  var result = yield fetch(url);
  console.log(result.bio);
}

var g = gen();
var result = g.next();

result.value.then(function(data){
  return data.json();
}).then(function(data){
  g.next(data);
});
```
4,async 函数
async 函数就是 Generator 函数的语法糖。
```
var fs = require('fs');

var readFile = function (fileName){
  return new Promise(function (resolve, reject){
    fs.readFile(fileName, function(error, data){
      if (error) reject(error);
      resolve(data);
    });
  });
};

var gen = function* (){
  var f1 = yield readFile('/etc/fstab');
  var f2 = yield readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};

写成 async 函数，就是下面这样。
var asyncReadFile = async function (){
  var f1 = await readFile('/etc/fstab');
  var f2 = await readFile('/etc/shells');
  console.log(f1.toString());
  console.log(f2.toString());
};
```

